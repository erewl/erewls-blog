---
layout: post
title:  "Playing around with GraalVM"
date:   2020-07-03 20:39:00 +0200
categories: graalvm scala native-image
---
# Building native images and compiling with GraalVM and sbt

At work we organized a two-day long Hackathon, a colleague and I took the chance to dig into the wonderful world of GraalVM. 

I've heard of GraalVM first around two years ago, where Oleg Å elajev toured through Java User Groups in Germany and held talks about GraalVM. [Here](https://www.youtube.com/watch?v=GinNxS3OSi0) is one from 2019 (not Germany, but Spain this time).

GraalVM promises a significant speed up in compile times and as I am working with Scala which is notoriously known for its long compile times this seems interesting.
Furthermore GraalVM provides functionality to build native executables. Meaning, an application can be run without a Java Virtual Machine.

Thanks to the Hackathon I took finally the time to get to know GraalVM a bit better.
With this blog post I want to share our findings, experiences and results, as they might be helpful for you too!

If you want to read a more elaborate answer to what GraalVM is.
You can expand the following section.

<details>
  <summary>About GraalVM</summary>

  ## What is GraalVM?

  GraalVM is a high-performance compiler. 
This should only give you a short understanding what it is and what it can do. You can read and watch more about it for example [here](), [here]() and [here]().

Our motivation for trying out GraalVM were tackling the pain points of Scala and Java projects and microservices.
Scala's long compile times and 
</details>

## Project setup
The project we worked on during the Hackathon is an API that is used to apply as an developer at the company.
Exposing one endpoint with which a resume and contact information can be submitted.

It is also a good project to test out GraalVM, nothing too complex but also as simple as "Hello World".

The full setup you can find [here](meaningfulgithublink TODO). But I'll give you a short summary:
The project is built around following libraries, no particular reason, simply because I like them.
- *cats* for working with effects, such as IO
- *http4s* for running the server
- *tapir* for defining the endpoints
- *circe* for json de/serialisation
- *pureconfig* for reading config-files
- *logback* for logging

The project can be run via `sbt run ` and with Postman or similar can be sent POST-request like so:
```
POST localhost:8080/api/v1/apply

{
    "email": "my@email.de",
    "name": "itsame",
    "phoneNumber": "1234567890",
    "applicationBase64": "VGhpcyBjb3VsZCBiZSB5b3VyIGFwcGxpY2F0aW9uIQ=="
}
```


## Setup GraalVM with sbt

With this initial project setup, GraalVM can be set up.

To compile and build native images with GraalVM you have prepare to things:
- install GraalVM
- add the sbt-native-packager to your project

Autocompletion should help you with finding the graal-commands, e.g.:
```sbt
sbt graalvm-native-image:packageBin
```
* * *

## Compiling and running
It has to be specified in sbt that not the regular JDK/JVM is used. This can be done with the `java_home` variable on sbt bootup:

```
export GRAAL_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-java8-20.1.0/Contents/Home
sbt -java-home $GRAALHOME
```
The path to GraalVM can vary depending on OS and installation. 
I followed the basic installation for MacOS.

We can also verify that sbt is using GraalVM like so:
```
$ sbt 
scala> eval System.getProperty("java.home")
[info] ans: String = /Library/Java/JavaVirtualMachines/graalvm-ce-java8-20.1.0/Contents/Home/jre
```

That means everything we run in your sbt instance, is running on and is getting compiled by GraalVM. Awesome!

Before getting started with native images, we will build a regular JAR-file.

With the [sbt-assembly](https://github.com/sbt/sbt-assembly) plugin you can create JAR-files with all of its dependencies (fat JARs).
`sbt assembly` creates this `target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar` file which you can just run with `java -jar target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar` from the root directory of this project.

I didn't measure the compile time and build time with GraalVM and to be honest with a project in this size I haven't noticed any significant difference. But there is this [post]() by So And So which benchmarks the compile times of a regular JVM and GraalVM.

In general, sbt's boot up time is just what is taking quite some time, and also with GraalVM as an underlying JVM I didn't notice a speed up with that.

Anyways, next step is now to become strong and independent and learn to run without an underlying JVM! We are going to build a native image.

## Building native images

### Setup

The GraalVM's [official website](https://www.graalvm.org/getting-started/#install-graalvm) provides guides to install it for every OS.
```
$ $GRAALHOME/bin/gu install native-image
```

The [sbt-native-packager](https://sbt-native-packager.readthedocs.io/en/latest/) provides functionality to build packages in an easy way (e.g. Docker) and it also provides support for building native images. 
In order to do so via sbt commands we will add this to our project:
```
// inside project/plugins.sbt
addSbtPlugin("com.typesafe.sbt" % "sbt-native-packager" % "1.7.3")
```
And in the project the `GraalVMNativeImagePlugin` needs to be enabled:
```
// inside build.sbt
enablePlugins(GraalVMNativeImagePlugin)
```

### First try building a native image

If you are still inside sbt, you might want to give it a `reload`. Next up we can run `sbt graalvm-native-image:packageBin` and see what we get. This might take a while (for me it took about a minute)

First we get a bunch of warnings:
```
[error] warning: unknown locality of class Lde/katrin/pricetracker/server/Main$anon$exportedReader$macro$24$1;, assuming class is not local. To remove the warning report an issue to the library or language author. The issue is caused by Lde/katrin/pricetracker/server/Main$anon$exportedReader$macro$24$1; which is not following the naming convention.

[error] warning: unknown locality of class Lfs2/internal/Algebra$Done$2$;, assuming class is not local. To remove the warning report an issue to the library or language author. The issue is caused by Lfs2/internal/Algebra$Done$2$; which is not following the naming convention.
```

But ultimately it fails with:
```
Error: com.oracle.graal.pointsto.constraints.UnresolvedElementException: Discovered unresolved type during parsing: org.slf4j.impl.StaticLoggerBinder. To diagnose the issue you can use the --allow-incomplete-classpath option. The missing type is then reported at run time when it is accessed the first time.
```
(TODO explain why)
(TODO INVESTIGATE ABOUT MACROS)

Actually some good hints on where to start fine-tuning the GraalVM config:

```
// inside build.sbt
graalVMNativeImageOptions ++= Seq(
  "-H:+ReportExceptionStackTraces",
  "--allow-incomplete-classpath",
)
```

`ReportExceptionStackTraces` does exactly what its name says, printing stack traces of exception which helps troubleshooting.

The option `allow-incomplete-classpath` also has a quite expressive name. Something's like, a `StaticLoggerBinder`, only get resolved at runtime, meaning at compile time the classpath can be incomplete.

During the build of a native image GraalVM tries to resolve those runtime dependencies already at compile time [SOURCE NEEDED STILL](). With this flag GraalVM knows "hey, don't worry about it now, we cross the bridge when we get there".

### Adding resource files

A `reload` (or restart) of sbt is needed to activate these new options. And we can try to build the native image up new.
This time the build finished successfully and the executable file `target/graalvm-native-image/apply-at-vdb` has been created!
This is an executable that can be run without a JVM:
```
$ target/graalvm-native-image/apply-at-vdb
```
But what's that? It actually cannot be started...
```
$ target/graalvm-native-image/apply-at-vdb

SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
*** An error occured! ***
Cannot convert configuration to a de.erewl.pricetracker.server.Config. Failures are:
  at the root:
    - Key not found: 'host'.
    - Key not found: 'port'.
```
The first three lines relate to the error that occurred during the first build. It simply says that logging hasn't been setup correctly (often due to the absence of a `src/main/resources/logback.xml`), triggering the default setting of not logging anything at all.
The second error states that a configuration file has not the right keys or cannot be found at all.
Looking into `src/main/resources`:
```
$ ls src/main/resources/
application.conf  logback.xml
```
and peeking into `application.conf`:
```
$ cat src/main/resources/application.conf
host = "localhost"
port = 8080
```
Hm, so everything is actually in place! But somehow GraalVM can't find them. 
It requires still some more GraalVM fine-tuning here.

By default GraalVM doesn't include any resource/configuration-files.
[-HIncludeResourceConfigurationFiles](https://www.graalvm.org/docs/Native-Image/user/RESOURCES)
The option `-H:IncludeResourceConfigurationFiles=path/to/resource-config.json` defines a path to a json-configuration file:
So inside the `resource-config.json` we can include our `application.conf` and our `logback.xml`. 
But writing those config files can be tedious and it is difficult in larger projects to find all necessary classes that need to be included.

GraalVM provides some support with writing those files and actually does all the work.
With the command `comaaaaaaand` GraalVM intercepts the dynamic lookups during runtime and write them to the files: `jni-config.json`, `proxy-config.json`, `reflect-config.json` and `resource-config.json`.
For now I just look at the latter.

Those generated files can be included in the GraalVMNativeImageOptions:
```
// in our build.sbt
graalVMNativeImageOptions ++= Seq(
  "-H:+ReportExceptionStackTraces",
  "--allow-incomplete-classpath",
  "-H:IncludeResourceConfigurationFiles=/configs/resource-config.json",
)
```
Hoping for the best, I built the image which was successful and start up the server:
```
$ target/graalvm-native-image/apply-at-vdb

SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
```
Hmmm, still no logging, sadly . But the server is actually running and can receive POST requests via its exposed endpoint:
```
POST localhost:8080/api/v1/apply

{
    "email": "my@email.de",
    "name": "itsame",
    "phoneNumber": "1234567890",
    "applicationBase64": "VGhpcyBjb3VsZCBiZSB5b3VyIGFwcGxpY2F0aW9uIQ=="
}
```

### Investigating the missing logging
It was a real head scratcher for me why the logging wasn't working.
I actually had to let this blog post rest for a few weeks and had a look at it.

So first I wanted to have a look if it was an overall issue with logging. 
I stepped back from using logging-framework and tried the most basic logging with the java-integrated `java.util.Logging`. GraalVM's docs stated that GraalVM supports any logging that depends on that. 

And with that logging was working.

So it must be something with the dependencies?

For further investigation, I added the dependency-graph viewer and checked out the dependency-tree with `sbt dependencyBrowserTree`. Logback wasn't included in the dependency tree.
Which is odd! Logback is clearly in the library-dependencies. 
```
// inside build.sbt
"ch.logback". % Runtime
```

But what's that? Logback's dependency has `% Runtime` appended. Probably from some weird copy pasting error that happened when gathering my dependencies.

I actually didn't know what this meant. So I looked it up, I found answers in the [sbt reference manual](https://www.scala-sbt.org/1.x/docs/Scopes.html#Scoping+by+the+configuration+axis)
and apparently Runtime defines the classpath when you run your program with `sbt run`. So this explains why logging was only working, when we run our server from inside sbt!

With removing this and building the native-image, logack appears in the depedency-tree, when the native image is run!!!

## Building the docker image


## Summary

The initial start and setup of GraalVM with sbt is pretty easy and straight forward.
Getting GraalVM to compile a sbt project is nice and simple. The challenge is to get it to build a good native image. This requires a lot of fine tuning. Getting the logging up and running on a native image was the biggest challenge for me with this small project.

* * * 
### Sources
Here are some articles, blog posts etc. that I read while working on this topic:

https://carolchen.me/blog/jits-intro/
https://carolchen.me/blog/jits-impls/