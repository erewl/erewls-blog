---
layout: post
title:  "Playing around with GraalVM"
date:   2020-07-03 20:39:00 +0200
categories: graalvm scala native-image
---
# Building native images and compiling with GraalVM and sbt

At work we organized a two-day long Hackathon, a colleague and I took the chance to dig into the wonderful world of GraalVM. 

I've heard of GraalVM first around two years ago, where Oleg Å elajev toured through Java User Groups in Germany and held talks about GraalVM. [Here](https://www.youtube.com/watch?v=GinNxS3OSi0) is one from 2019 (not Germany, but Spain this time).

Thanks to the Hackathon I took finally the time to get to know GraalVM a bit better.
With this blog post I want to share our findings, experiences and results, as they might be helpful for you too!

* * *
## What is GraalVM?
GraalVM is a high-performance compiler that 
This should only give you a short understanding what it is and what it can do. You can read and watch more about it for example [here](), [here]() and [here]().

Our motivation for trying out GraalVM were tackling the pain points of Scala and Java projects and microservices.
Scala's long compile times and 
* * *
## Project setup

As an example project I thought of a simple use case, yet a bit more complex than just "Hello World!".
We are using an API that exposes one endpoint.
The full setup you can find [here](meaningfulgithublink TODO). But I'll give you a short summary:
The project is built around following libraries, no particular reason, simply because I like them.
- cats for working with effects, such as IO
- http4s for running the server
- tapir for defining the endpoints
- pureconfig for reading config-files
- circe for json de/serialisation
- logback for logging

In Jens Grassel's book [pfhais](leanpub link) I have first saw the transactional start up of a server, which I really liked and used it in this project as well. 
(maybe this can go out)

* * *
## Setup GraalVM with sbt

Now that we have our initial project all set up we can continue with adding GraalVM to our project.
To compile and build native images with GraalVM you have prepare to things:
- install GraalVM
- add the sbt-native-packager to your project

Autocompletion should help you with finding the graal-commands, e.g.:
```sbt
sbt graalvm-native-image:packageBin
```
* * *

## Compiling and running
To start compiling with GraalVM you have to specify the `java_home` variable when booting up sbt, if it is not your main Java-Version on your machine:
```
export GRAAL_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-java8-20.1.0/Contents/Home
sbt -java-home $GRAALHOME
```
We can also verify that sbt is using GraalVM like so
```
$ sbt console
[info] Starting scala interpreter...
Welcome to Scala 2.12.10 (OpenJDK 64-Bit Server VM GraalVM CE 20.1.0, Java 1.8.0_252).
Type in expressions for evaluation. Or try :help.
scala> :q
```
(for non vim users it might not seem too trivial to be able to exit the console via the last command `:q`, I was one of them ;) )

That means everything we run in your sbt instance, is running on and is getting compiled by GraalVM. Awesome!

Before getting started with native images, we will build a regular JAR-file.

With the [sbt-assembly](https://github.com/sbt/sbt-assembly) plugin you can create JAR-files with all of its dependencies (fat JARs).
`sbt assembly` creates this `target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar` file which you can just run with `java -jar target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar` from the root directory of this project.

I didn't measure the compile time and build time with GraalVM and to be honest with a project in this size I haven't noticed any significant difference. But there is this [post]() by So And So which benchmarks the compile times of a regular JVM and GraalVM.

In general, sbt's boot up time is just what is taking quite some time, even with GraalVM as and underlying JVM.
In this project it was still bearable but in larger project it becomes problematic.

Anyways, next step is now to become strong and independent and learn to run without an underlying JVM! We are going to build a native image.

## Building native images

### Setup

The GraalVM's [official website](https://www.graalvm.org/getting-started/#install-graalvm) provides guides to install it for every OS.
```
$ $GRAALHOME/bin/gu install native-image
```

The [sbt-native-packager](https://sbt-native-packager.readthedocs.io/en/latest/) provides functionality to build packages in an easy way (e.g. Docker) and it also provides support for building native images. 
In order to do so via sbt commands we will add this to our project:
```
// in your project/plugins.sbt
addSbtPlugin("com.typesafe.sbt" % "sbt-native-packager" % "1.7.3")
```
And in our project we will enable the `GraalVMNativeImagePlugin`:
```
// in your build.sbt
enablePlugins(GraalVMNativeImagePlugin)
```

### First try building a native image

If you are still inside sbt, you might want to give it a `reload`. Next up we can run `sbt graalvm-native-image:packageBin` and see what we get. This might take a while (for me it took about a minute)

First we get a bunch of warnings:
```
[error] warning: unknown locality of class Lde/katrin/pricetracker/server/Main$anon$exportedReader$macro$24$1;, assuming class is not local. To remove the warning report an issue to the library or language author. The issue is caused by Lde/katrin/pricetracker/server/Main$anon$exportedReader$macro$24$1; which is not following the naming convention.

[error] warning: unknown locality of class Lfs2/internal/Algebra$Done$2$;, assuming class is not local. To remove the warning report an issue to the library or language author. The issue is caused by Lfs2/internal/Algebra$Done$2$; which is not following the naming convention.
```

But ultimately it fails with:
```
Error: com.oracle.graal.pointsto.constraints.UnresolvedElementException: Discovered unresolved type during parsing: org.slf4j.impl.StaticLoggerBinder. To diagnose the issue you can use the --allow-incomplete-classpath option. The missing type is then reported at run time when it is accessed the first time.
```
(TODO explain why)
(TODO INVESTIGATE ABOUT MACROS)

So we do as advised and start fine-tuning our GraalVM-setup:

```
// in our build.sbt
graalVMNativeImageOptions ++= Seq(
  "-H:+ReportExceptionStackTraces",
  "--allow-incomplete-classpath",
)
```
`ReportExceptionStackTraces` does exactly what its name says, prints stack traces of exception which helps troubleshooting.

The option `allow-incomplete-classpath` also has a quite expressive name. Something's like, the StaticLoggerBinder, only get resolved at runtime, meaning the at compile time the classpath can be incomplete.
During the build of a native image GraalVM tries to resolve those runtime dependencies already at compile time [SOURCE NEEDED STILL](). With this flag we say GraalVM "hey, don't worry about it now, we cross the bridge when we get there".

### Adding resource files

A `reload` (or restart) of sbt is needed to activate these new options. And we can try to build the native image up new.
This time the build finished successfully and the executable file `target/graalvm-native-image/apply-at-vdb` has been created!
This is an executable we can run without a JVM:
```
$ target/graalvm-native-image/apply-at-vdb
```
But what's that? We can't actually start it!
```
$ target/graalvm-native-image/apply-at-vdb

SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
*** An error occured! ***
Cannot convert configuration to a de.erewl.pricetracker.server.Config. Failures are:
  at the root:
    - Key not found: 'host'.
    - Key not found: 'port'.
```
The first three lines relate to the error that occurred during the first build. It simply says that logging hasn't been setup correctly (often due to the absence of a `src/main/resources/logback.xml`), triggering the default setting of not logging anything at all.
The second error states that a configuration file has not the right keys or cannot be found at all.
Looking into `src/main/resources`:
```
$ ls src/main/resources/
application.conf  logback.xml
```
and peeking into `application.conf`:
```
$ cat src/main/resources/application.conf
host = "localhost"
port = 8080
```
Hm, so everything is actually in place! But somehow GraalVM can't find them. 
We have to do more GraalVM fine-tuning here.
By default GraalVM doesn't include any resource/configuration-files.
[-HIncludeResourceConfigurationFiles](https://www.graalvm.org/docs/Native-Image/user/RESOURCES)
The option `-H:IncludeResourceConfigurationFiles=path/to/resource-config.json` defines a path to a json-configuration file:
So inside the `resource-config.json` we can include our `application.conf` and our `logback.xml`. Or we can let GraalVM help us with building this file.
With the command `comaaaaaaand` GraalVM intercepts the dynamic lookups during runtime and write them to the files: `jni-config.json`, `proxy-config.json`, `reflect-config.json` and `resource-config.json`.
For now I just look at the latter.

I include the path to this generated file in the GraalVMNativeImageOptions:
```
// in our build.sbt
graalVMNativeImageOptions ++= Seq(
  "-H:+ReportExceptionStackTraces",
  "--allow-incomplete-classpath",
  "-H:IncludeResourceConfigurationFiles=/configs/resource-config.json",
)
```
Hoping for the best, I built the image, start up the server:
```
$ target/graalvm-native-image/apply-at-vdb

SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
```
Hmmm, still no logging, sadly . But we can finally  send a POST request to our exposed endpoint via Postman or similar:
```
POST localhost:8080/api/v1/apply

{
    "email": "my@email.de",
    "name": "itsame",
    "phoneNumber": "1234567890",
    "applicationBase64": "VGhpcyBjb3VsZCBiZSB5b3VyIGFwcGxpY2F0aW9uIQ=="
}
```

### Investigating the missing logging
It was a real head scratcher for me why the logging wasn't working.
I actually had to let this blog post rest for a few weeks and had a look at it.
So first I wanted to have a look if it was an overall issue with logging. So I tried the `java.util.Logging` library as it stated that GraalVM supports any logging that depends on that. And with that logging was working.
So it must be something with the dependencies? Is logback and slf4j not depending on this?

For further investigation, I added the dependency-graph viewer and checked out the dependency-tree with `sbt dependencyBrowserTree`. Logback wasn't included in the dependency tree.
Which is odd! Logback is clearly in the library-dependencies. But when I looked into it I saw that it at `% Runtime` appended. Probably from some weird copy pasting that I do when gathering my dependencies.
I actually didn't know what this meant. So I looked it up, I found answers in the [sbt reference manual](https://www.scala-sbt.org/1.x/docs/Scopes.html#Scoping+by+the+configuration+axis)
and apparently Runtime defines the classpath when you run your program with `sbt run`. So this explains why logging was only working, when we run our server from inside sbt!

I am so happy that this was fixable so easily! But daaaamn, that took me some time to figure out :')

## Summary

The initial start and setup of GraalVM with sbt is pretty easy and straight forward.
Getting GraalVM to compile a sbt project is nice and simple. The challenge is to get it to build a good native image. This requires a lot of fine tuning. Getting the logging up and running on a native image was the biggest challenge for me with this small project.

* * *

The next post will be about getting the native image inside a docker container.
This will be actually a bit more straight forward

* * * 
### Sources
Here are some articles, blog posts etc. that I read while working on this topic:

https://carolchen.me/blog/jits-intro/
https://carolchen.me/blog/jits-impls/