<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="/erewls-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="/erewls-blog/" rel="alternate" type="text/html" /><updated>2020-10-24T20:18:48+00:00</updated><id>/erewls-blog/feed.xml</id><title type="html">erewl’s blog</title><subtitle>I like art, music, photography, programming and learning new stuff. Welcome to my blog!</subtitle><entry><title type="html">Building native images and compiling with GraalVM and sbt</title><link href="/erewls-blog/2020/10/06/graalvm.html" rel="alternate" type="text/html" title="Building native images and compiling with GraalVM and sbt" /><published>2020-10-06T00:00:00+00:00</published><updated>2020-10-06T00:00:00+00:00</updated><id>/erewls-blog/2020/10/06/graalvm</id><content type="html" xml:base="/erewls-blog/2020/10/06/graalvm.html">&lt;p&gt;At &lt;a href=&quot;https://vandebron.tech&quot;&gt;Vandebron&lt;/a&gt; we organize a two-day long Hackathon every quarter, and a colleague and I took this chance to dig into the wonderful world of GraalVM.&lt;/p&gt;

&lt;p&gt;I’ve first heard of GraalVM around two years ago when Oleg Šelajev toured through Java User Groups in Germany and held talks about GraalVM. &lt;a href=&quot;https://www.youtube.com/watch?v=GinNxS3OSi0&quot;&gt;Here&lt;/a&gt; is one from 2019 (not Germany, but Spain this time).&lt;/p&gt;

&lt;p&gt;GraalVM promises a significant speedup in compile times and as I am working with Scala, which is notoriously known for its long compile times, this seems interesting. Furthermore, GraalVM provides functionality to build native executables. Meaning, an application can be run without a Java Virtual Machine (JVM).&lt;/p&gt;

&lt;p&gt;Thanks to the Hackathon I finally took the time to get to know GraalVM a bit better. With this blog post, I want to share our findings, experiences, and results, as they might be helpful for you too!&lt;/p&gt;

&lt;h2 id=&quot;what-is-graalvm&quot;&gt;What is GraalVM?&lt;/h2&gt;

&lt;p&gt;GraalVM is a high-performance JVM that supports efficient ahead-of-time (AOT) and just-in-time (JIT) compilation, but also allows non-JVM languages (e.g. Ruby, Python, C++) to run on the JVM. The ahead-of-time compilation feature is the base for creating native executable programs, meaning an application can be run independently from the JVM. Seeing the versatile features of GraalVM, it is worth looking a bit under its hood.&lt;/p&gt;

&lt;p&gt;Actually, GraalVM is defined by three main technologies:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.graalvm.org/reference-manual/jvm/&quot;&gt;Graal compiler&lt;/a&gt;, a high-performance JIT-compiler that can make JVM applications run faster from within the JVM&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.graalvm.org/reference-manual/native-image/SubstrateVM/&quot;&gt;SubstrateVM&lt;/a&gt;, includes the necessary components to run a JVM-app as a native executable ( Garbage Collector, Thread Scheduler, etc.)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/&quot;&gt;Truffle Language Implementation Framework&lt;/a&gt;, the basis for the polyglot support from GraalVM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our motivation for trying out GraalVM was tackling the pain points of Scala, Java projects, and microservices. Shipping microservices written in Scala as Docker containers to your production system comes with the cost that startup can be a bit slow, having JVM and Docker overhead, and that those containers can be fairly large, as the application can only be run with a JVM. See &lt;a href=&quot;#building-docker-images&quot;&gt;Building Docker images&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;During the hackathon, we were most interested in building native images for Scala applications. Hoping to reduce the size of our docker containers and reducing up the startup time.&lt;/p&gt;

&lt;h2 id=&quot;project-setup&quot;&gt;Project setup&lt;/h2&gt;

&lt;p&gt;The project we worked on during the Hackathon is an API that should be used for applicants to submit their applications at Vandebron in the future. By exposing one endpoint through which a resume and contact information can be submitted.&lt;/p&gt;

&lt;p&gt;It is also a good project to test out GraalVM, nothing too complex but also not as simple as “Hello World”.&lt;/p&gt;

&lt;p&gt;The full setup can be found &lt;a href=&quot;https://github.com/kgrunert/apply-at-vdb&quot;&gt;on Github&lt;/a&gt;. But I’ll summarise the used stack below. The project is built around the following libraries, no particular reason, simply because I like them.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;cats&lt;/em&gt; for working with effects, such as IO&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;http4s&lt;/em&gt; for running the server&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;tapir&lt;/em&gt; for defining the endpoints&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;circe&lt;/em&gt; for JSON de/serialisation&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;pureconfig&lt;/em&gt; for reading config-files&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;logback&lt;/em&gt; for logging&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The project can be run via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt run&lt;/code&gt; and with Postman or similar a POST-request can be sent like so:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST localhost:8080/api/v1/apply

{
	&quot;email&quot;: &quot;my@email.de&quot;,
	&quot;name&quot;: &quot;My Name&quot;,
	&quot;phoneNumber&quot;: &quot;+310123456789&quot;,
	&quot;applicationBase64&quot;: &quot;VGhpcyBjb3VsZCBiZSB5b3VyIGFwcGxpY2F0aW9uIQ==&quot;
}

Response:
&quot;*confetti* Thanks for handing in your application, we will get back to you within the next days! *confetti*&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;setup-graalvm-with-sbt&quot;&gt;Setup GraalVM with sbt&lt;/h2&gt;

&lt;p&gt;With this initial project setup in mind, GraalVM needs to be installed locally.&lt;/p&gt;

&lt;p&gt;For the installation of GraalVM the &lt;a href=&quot;https://www.graalvm.org/docs/getting-started-with-graalvm/#install-graalvm&quot;&gt;setup guide&lt;/a&gt; can be followed.&lt;/p&gt;

&lt;p&gt;After the installation sbt needs to know that not the regular JDK/JVM is used. This can be done with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java-home&lt;/code&gt; option on sbt bootup.
To make the path to GraalVM a bit more accessible and easy to use it can be exported as an environment variable.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;GRAAL_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/Library/Java/JavaVirtualMachines/graalvm-ce-java8-20.1.0/Contents/Home
sbt &lt;span class=&quot;nt&quot;&gt;-java-home&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$GRAALHOME&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The path to GraalVM can vary depending on OS and installation. We followed the basic installation for macOS.&lt;/p&gt;

&lt;p&gt;Now sbt using GraalVM can be verified with:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sbt &lt;span class=&quot;nt&quot;&gt;-java-home&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$GRAALHOME&lt;/span&gt;
scala&amp;gt; &lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;System.getProperty&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;java.home&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;info] ans: String &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /Library/Java/JavaVirtualMachines/graalvm-ce-java8-20.1.0/Contents/Home/jre
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That means everything running in this sbt instance is getting compiled by GraalVM. Awesome!&lt;/p&gt;

&lt;p&gt;The next step is to become strong and independent and learn how to run without an underlying JVM with the help of building native images.&lt;/p&gt;

&lt;h2 id=&quot;building-native-images&quot;&gt;Building native images&lt;/h2&gt;

&lt;p&gt;GraalVM ships with the &lt;a href=&quot;https://www.graalvm.org/reference-manual/graalvm-updater/&quot;&gt;GraalVM Updater&lt;/a&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gu&lt;/code&gt;) to install the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;native-image&lt;/code&gt; on your machine.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$GRAALHOME&lt;/span&gt;/bin/gu &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;native-image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://sbt-native-packager.readthedocs.io/en/latest/&quot;&gt;sbt-native-packager&lt;/a&gt; provides functionality to build packages efficiently (e.g. building Docker images) and added to that, it also provides support for building native images.
In order to build native images with sbt commands this plugin has to be added to the project:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// inside project/plugins.sbt&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;addSbtPlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.typesafe.sbt&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sbt-native-packager&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.7.3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GraalVMNativeImagePlugin&lt;/code&gt; needs to be enabled:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// inside build.sbt&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;enablePlugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GraalVMNativeImagePlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From within sbt it should be able to autocomplete and suggest graal-commands, e.g.:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sbt&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;apply-at-vdb&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;graalvm&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;graalvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;native&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;kt&quot;&gt;graalvmNativeImageOptions&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that setup, native images are just a stone’s throw away!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h3&gt;

&lt;p&gt;The next three sections are not a write-up but rather the main steps we had to take to make the project work. This includes failing images and troubleshooting.
I want to keep this in because it might be interesting for others when they have to troubleshoot.
For the summary and happy path, you can jump directly to &lt;a href=&quot;#roundup&quot;&gt;Roundup&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;first-try-building-a-native-image&quot;&gt;First try building a native image&lt;/h3&gt;

&lt;p&gt;Next up &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graalvm-native-image:packageBin&lt;/code&gt; can be run from within sbt. This might take a while (on our systems it took about a minute)&lt;/p&gt;

&lt;p&gt;Some warnings start to pop up:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[error] warning: unknown locality of class Lnl/vandebron/applyatvdb/Main$anon$exportedReader$macro$24$1;, assuming class is not local. To remove the warning report an issue to the library or language author. The issue is caused by Lnl/vandebron/applyatvdb/Main$anon$exportedReader$macro$24$1; which is not following the naming convention.

[error] warning: unknown locality of class Lfs2/internal/Algebra$Done$2$;, assuming class is not local. To remove the warning report an issue to the library or language author. The issue is caused by Lfs2/internal/Algebra$Done$2$; which is not following the naming convention.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The library-specific warnings can be ignored for now. Ultimately it fails with:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error: com.oracle.graal.pointsto.constraints.UnresolvedElementException:
Discovered unresolved type during parsing: org.slf4j.impl.StaticLoggerBinder.
To diagnose the issue you can use the --allow-incomplete-classpath option.
The missing type is then reported at run time when it is accessed the first time.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Actually a good hint on where to start fine-tuning the GraalVM config:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// inside build.sbt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;graalVMNativeImageOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;--allow-incomplete-classpath&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some things like a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StaticLoggerBinder&lt;/code&gt; only get resolved at runtime, meaning at build time the classpath needs to be allowed to be incomplete. This option allows resolution errors to be ignored at build time and only pop up during runtime.&lt;/p&gt;

&lt;p&gt;During the build of a native image, GraalVM tries to resolve those runtime dependencies already at compile-time, as it is part of the Ahead-Of-Time-compilation process. With this flag, GraalVM knows “hey, don’t worry about it now, we cross the bridge when we get there” (or something like that).&lt;/p&gt;

&lt;h3 id=&quot;adding-resource-files&quot;&gt;Adding resource files&lt;/h3&gt;

&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reload&lt;/code&gt; (or restart) of sbt is needed to activate these new options. And we can try to build the native image up new.
This time the build finished successfully and the executable file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target/graalvm-native-image/apply-at-vdb&lt;/code&gt; has been created!
This is an executable that can be run without a JVM:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target/graalvm-native-image/apply-at-vdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But what’s that? It actually cannot be started…&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target/graalvm-native-image/apply-at-vdb

SLF4J: Failed to load class &lt;span class=&quot;s2&quot;&gt;&quot;org.slf4j.impl.StaticLoggerBinder&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
SLF4J: Defaulting to no-operation &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;NOP&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;further details.
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; An error occured! &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;
Cannot convert configuration to a de.erewl.pricetracker.server.Config. Failures are:
at the root:
- Key not found: &lt;span class=&quot;s1&quot;&gt;'host'&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
- Key not found: &lt;span class=&quot;s1&quot;&gt;'port'&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first three lines relate to the error that occurred during the first build. It simply says that logging hasn’t been set up correctly (maybe due to the absence of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src/main/resources/logback.xml&lt;/code&gt; or some other misconfiguration), triggering the default setting of not logging anything at all.
The second error states that a configuration file does not have the right keys or cannot be found at all.
Looking into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src/main/resources&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;ls &lt;/span&gt;src/main/resources/
application.conf logback.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and peeking into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application.conf&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;src/main/resources/application.conf
	host &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;localhost&quot;&lt;/span&gt;
	port &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hm, so everything is actually in place. But somehow GraalVM can’t find those files.
It still requires some more GraalVM fine-tuning here.&lt;/p&gt;

&lt;p&gt;By default, GraalVM doesn’t include any resource or configuration-files.
The option &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H:ResourceConfigurationFiles=path/to/resource-config.json&lt;/code&gt; defines a path to a JSON configuration file. So inside the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resource-config.json&lt;/code&gt; we can include our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application.conf&lt;/code&gt; and our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logback.xml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But writing those config files can be tedious and it is difficult in larger projects to find all necessary classes that need to be included. GraalVM provides some support with writing those files and actually does all the work. In the project’s root directory a configs-folder can be created which will contain all necessary config-files.&lt;/p&gt;

&lt;p&gt;For writing the configuration files we will build a normal JAR-file with the help of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt-assembly&lt;/code&gt; plugin. Adding it to the project like so:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// inside project/plugins.sbt&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;addSbtPlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.eed3si9n&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sbt-assembly&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.14.6&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The JAR-file will be built with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt assembly&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With that we can now start the application, providing the path to the JAR-file that just has been created:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;configs
&lt;span class=&quot;nv&quot;&gt;$GRAALHOME&lt;/span&gt;/bin/java &lt;span class=&quot;nt&quot;&gt;-agentlib&lt;/span&gt;:native-image-agent&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;config-output-dir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;./configs &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With the command above the JAR gets to run with GraalVM but adds &lt;a href=&quot;https://www.graalvm.org/reference-manual/native-image/Configuration/#assisted-configuration-of-native-image-builds&quot;&gt;dynamic lookups&lt;/a&gt; that are being intercepted during runtime and written to the files: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jni-config.json&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy-config.json&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reflect-config.json&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resource-config.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Those generated files can be included in the GraalVMNativeImageOptions:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// build.sbt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;graalVMNativeImageOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;--allow-incomplete-classpath&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;-H:ResourceConfigurationFiles=../../configs/resource-config.json&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;-H:ReflectionConfigurationFiles=../../configs/reflect-config.json&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;-H:JNIConfigurationFiles=../../configs/jni-config.json&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;-H:DynamicProxyConfigurationFiles=../../configs/proxy-config.json&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The build with those updated options should succeed and the app can be run once again:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target/graalvm-native-image/apply-at-vdb

SLF4J: Failed to load class &lt;span class=&quot;s2&quot;&gt;&quot;org.slf4j.impl.StaticLoggerBinder&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
SLF4J: Defaulting to no-operation &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;NOP&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;further details.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Still no logging, sadly. But the server is actually running and responds to POST requests via its exposed endpoint:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST localhost:8080/api/v1/apply

{
	&quot;email&quot;: &quot;my@email.de&quot;,
	&quot;name&quot;: &quot;My Name&quot;,
	&quot;phoneNumber&quot;: &quot;+310123456789&quot;,
	&quot;applicationBase64&quot;: &quot;VGhpcyBjb3VsZCBiZSB5b3VyIGFwcGxpY2F0aW9uIQ==&quot;
}

Response:
&quot;*confetti* Thanks for handing in your application, we will get back to you within the next days! *confetti*&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next and last step will investigate why logging is not picked up by GraalVM.&lt;/p&gt;

&lt;h3 id=&quot;investigating-the-missing-logging&quot;&gt;Investigating the missing logging&lt;/h3&gt;

&lt;p&gt;So first I wanted to have a look if it was an overall issue with logging. I stepped back from using logging-framework and tried the most basic logging with the java-integrated &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.Logging&lt;/code&gt;. GraalVM’s &lt;a href=&quot;https://www.graalvm.org/docs/Native-Image/user/LOGGING&quot;&gt;docs&lt;/a&gt; stated that GraalVM supports any logging that depends on that.&lt;/p&gt;

&lt;p&gt;Building and running the native-image with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.Logging&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logback&lt;/code&gt; succeeded and everything is logged properly.&lt;/p&gt;

&lt;p&gt;So it must be something with the dependencies?&lt;/p&gt;

&lt;p&gt;For further investigation, I added the &lt;a href=&quot;https://github.com/jrudolph/sbt-dependency-graph&quot;&gt;sbt-dependency-graph&lt;/a&gt; plugin and checked out the dependency-tree with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt dependencyBrowserTree&lt;/code&gt;. The library &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logback&lt;/code&gt; wasn’t included in the dependency tree.
Which is odd, since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logback&lt;/code&gt; is clearly present in the project’s library-dependencies.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// inside build.sbt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;libraryDependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;logback-classic&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.3&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;logback-core&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.2.3&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Having a closer look, the appendix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;% Runtime&lt;/code&gt; on logback’s dependency is present.&lt;/p&gt;

&lt;p&gt;Not sure where this was coming from but it is most probably blindly copy-pasted from somewhere when gathering the dependencies for this project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.scala-sbt.org/1.x/docs/Scopes.html#Scoping+by+the+configuration+axis&quot;&gt;sbt reference manual&lt;/a&gt; states that the appendix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime&lt;/code&gt; defines that this dependency will be only included in the runtime classpath.&lt;/p&gt;

&lt;p&gt;So this explains probably why logging was only working when the server was run from inside sbt.&lt;/p&gt;

&lt;p&gt;With removing this and building the native-image, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logback&lt;/code&gt; appears in the dependency-tree, and logging works when the native image is executed!&lt;/p&gt;

&lt;p&gt;This “bug” was interesting as it emphasized what GraalVM can NOT do for you. Dynamic class loading/linking can not be supported by GraalVM as classes and dependencies have to be present during compile time to make a fully functional application.&lt;/p&gt;

&lt;h3 id=&quot;roundup&quot;&gt;Roundup&lt;/h3&gt;

&lt;p&gt;A successful setup of sbt and GraalVM to build native-images requires to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;install GraalVM’s native-image functionality via it’s graal-updater:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gu &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;native-image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;add sbt-native-packager and sbt-assembly to sbt:
    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// inside project/plugins.sbt&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;addSbtPlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.typesafe.sbt&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sbt-native-packager&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.7.3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;addSbtPlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.eed3si9n&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sbt-assembly&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.14.6&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;enable the GraalVM-Plugin:
    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// inside build.sbt&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;enablePlugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GraalVMNativeImagePlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;create a fat JAR and define which resource and configuration files should be intergated by intercepting look up calls during its execution:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sbt assembly
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;configs
&lt;span class=&quot;nv&quot;&gt;$GRAALHOME&lt;/span&gt;/bin/java &lt;span class=&quot;nt&quot;&gt;-agentlib&lt;/span&gt;:native-image-agent&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;config-output-dir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;./configs &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;fine-tune GraalVM with the following options and include the files that have been created in the previous step:
    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// build.sbt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;graalVMNativeImageOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;--allow-incomplete-classpath&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;-H:ResourceConfigurationFiles=../../configs/resource-config.json&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;-H:ReflectionConfigurationFiles=../../configs/reflect-config.json&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;-H:JNIConfigurationFiles=../../configs/jni-config.json&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;-H:DynamicProxyConfigurationFiles=../../configs/proxy-config.json&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;build the native image with:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sbt graalvm-native-image:packageBin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;run the executable file without the need of java
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./target/graalvm-native-image/apply-at-vdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even without benchmarking, you notice that the startup time is way faster than with a traditional JAR-file and the application is up and running almost instantly.&lt;/p&gt;

&lt;p&gt;It is worth noting that the creation of a native image is a quite time-consuming process. For this project, it took between 1 and 2 minutes. This is, of course, something a CI/CD-Server like Jenkins would take care of but it has to be kept in mind.&lt;/p&gt;

&lt;p&gt;With a working native-image, it is time to dockerize.&lt;/p&gt;

&lt;h2 id=&quot;building-docker-images&quot;&gt;Building Docker images&lt;/h2&gt;

&lt;p&gt;In this section two Docker containers will be built. One, following the “normal”-java way and the other will be using the native-image to build a Docker-container without Java.&lt;/p&gt;

&lt;p&gt;Before getting started with native images, a regular JAR-file and Docker image for comparison can be built.&lt;/p&gt;

&lt;p&gt;With the &lt;a href=&quot;https://github.com/sbt/sbt-assembly&quot;&gt;sbt-assembly&lt;/a&gt; plugin you can create JAR-files with all of its dependencies (fat JARs).
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt assembly&lt;/code&gt; creates this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar&lt;/code&gt; which has a size of around 42MB:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sbt assembly 
 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-lh&lt;/span&gt; target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar

  ...  ...   42M   target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This application can be run locally via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java -jar target/scala-2.12/apply-at-vdb-assembly-0.1.0-SNAPSHOT.jar&lt;/code&gt; with the prerequisite that Java is installed on that machine.&lt;/p&gt;

&lt;p&gt;Creating the Docker image for this JAR-file can be done manually, but luckily &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt-native-package&lt;/code&gt; supports building regular Docker images out of the box, only the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DockerPlugin&lt;/code&gt; needs to be enabled:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// build.sbt&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;enablePlugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DockerPlugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sbt docker:publishLocal&lt;/code&gt; creates the Docker image &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply-at-vdb&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker images | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;apply-at-vdb
  apply-at-vdb 	0.1.0-SNAPSHOT 		f488d4c06f28 	555MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A whopping 555MB for a tiny app exposing one endpoint which JAR-file was only 42MB. But to run this JAR-file in a container, this container needs to ship with a JVM, and that’s where the overhead lies.&lt;/p&gt;

&lt;p&gt;With that Docker image and JAR-file as a reference, we can now look into how the native-image operates together with Docker.&lt;/p&gt;

&lt;p&gt;GraalVM does not support cross-building, meaning an application cannot be expected to be built in a MacOS environment and run in a Linux environment. It has to be built and run on the same platform. With the help of Docker, the desired built environment can be provided.
The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; looks as follows:&lt;/p&gt;
&lt;div class=&quot;language-docker highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; oracle/graalvm-ce AS builder&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /app/vdb&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;gu &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;native-image
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;curl https://bintray.com/sbt/rpm/rpm &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; bintray-sbt-rpm.repo &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;mv &lt;/span&gt;bintray-sbt-rpm.repo /etc/yum.repos.d/ &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; sbt
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; . /app/vdb&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /app/vdb&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;sbt &lt;span class=&quot;s2&quot;&gt;&quot;graalvm-native-image:packageBin&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; oraclelinux:7-slim&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; --from=builder /app/vdb/target/graalvm-native-image/apply-at-vdb ./app/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; ./app/apply-at-vdb&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And can be run with:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; native-apply-at-vdb &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The Dockerfile describes to do the following:
The first docker container, as the name implies, is the builder. As a base image the official &lt;a href=&quot;https://hub.docker.com/r/oracle/graalvm-ce&quot;&gt;GraalVM image&lt;/a&gt; is used.&lt;/p&gt;

&lt;p&gt;This image needs two more things, GraalVM’s native-image command, and sbt, and this is what the two follow-up rows are providing. Once that’s done, the project is copied into this container and the native image is built from within sbt.&lt;/p&gt;

&lt;p&gt;The next steps bring the native executable into its own docker container.
As a base image, we use an Oracle Linux image and from our builder-container, we copy the native executable to this new container. The last step is that the app gets run on container startup.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -p 8080:8080 -it native-apply-at-vdb&lt;/code&gt; starts the container and shows that everything is working just as before.&lt;/p&gt;

&lt;p&gt;But what about the image size? Let’s have a look.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker images | grep apply-at-vdb
  native-apply-at-vdb		latest              17b559e78645		199MB
  apply-at-vdb			0.1.0-SNAPSHOT      f488d4c06f28		555MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;That is impressive! We created an app that is approx. 2.8 times smaller than our original app.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We learned how to set up a Scala project with GraalVM, what steps have to be taken to build a native image with GraalVM, and let it run inside a Docker container. We also received a good overview of what’s possible with GraalVM and what’s not.&lt;/p&gt;

&lt;p&gt;The initial start and setup of GraalVM with sbt is pretty easy and straightforward. Getting GraalVM to compile an sbt project is nice and simple.&lt;/p&gt;

&lt;p&gt;This Hackathon showed us that it is difficult and requires a lot of fine-tuning to integrate GraalVM into an existing project or product. At Vandebron we work with a complex stack of technologies including Spark, Kafka, and Akka which made it difficult to port the findings from this small toy service to one of our existing microservices. This made extensive troubleshooting in the Hackathon not possible.&lt;/p&gt;

&lt;p&gt;All in all, GraalVM allows you to give up some Java overhead and create significant smaller Docker images. Sadly, this comes at the cost of giving up dynamic linking and class loading. 
A silver lining is, that inside Scala’s ecosystem this rarely a problem. Scala relies heavily on compile-time mechanisms for detecting bugs early and creating type-safe applications (read &lt;a href=&quot;https://blog.softwaremill.com/small-fast-docker-images-using-graalvms-native-image-99c0bc92e70b&quot;&gt;here&lt;/a&gt; but also see e.g. &lt;a href=&quot;https://typelevel.org/scala/docs/phases.html&quot;&gt;Scala’s compiler phases&lt;/a&gt;).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;sources-and-reading&quot;&gt;Sources and Reading&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inner-product.com/posts/serverless-scala-services-with-graalvm/&quot;&gt;Building Serverless Scala Services with GraalVM&lt;/a&gt; by Noel Welsh&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.softwaremill.com/small-fast-docker-images-using-graalvms-native-image-99c0bc92e70b&quot;&gt;Small &amp;amp; fast Docker images using GraalVM’s native-image&lt;/a&gt; by Adam Warski&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/rahasak/run-scala-applications-with-graalvm-and-docker-a1e67701e935&quot;&gt;Run Scala applications with GraalVM and Docker&lt;/a&gt; by @itseranga&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/graalvm/getting-started-with-graalvm-for-scala-d0a006dec1d1&quot;&gt;Getting Started with GraalVM and Scala&lt;/a&gt; by Oleg Šelajev&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/graalvm/updates-on-class-initialization-in-graalvm-native-image-generation-c61faca461f7&quot;&gt;Updates on Class Initialization in GraalVM Native Image Generation&lt;/a&gt; by 
Christian Wimmer&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.graalvm.org/reference-manual/&quot;&gt;GraalVM’s Reference Manuals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>erewl</name></author><category term="graalvm" /><category term="scala" /><category term="native-image" /><summary type="html">At Vandebron we organize a two-day long Hackathon every quarter, and a colleague and I took this chance to dig into the wonderful world of GraalVM.</summary></entry><entry><title type="html">Scio me nescire</title><link href="/erewls-blog/2020/07/01/hello-world.html" rel="alternate" type="text/html" title="Scio me nescire" /><published>2020-07-01T12:51:50+00:00</published><updated>2020-07-01T12:51:50+00:00</updated><id>/erewls-blog/2020/07/01/hello-world</id><content type="html" xml:base="/erewls-blog/2020/07/01/hello-world.html">&lt;p&gt;Hi! And welcome to my very first blog post.
I have been struggling to start writing a blog for a long time for various reasons. I could list all reasons, however, thinking about it they all boil down to one main problem:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scio me nescire&lt;/strong&gt; - I know that I know nothing.&lt;/p&gt;

&lt;p&gt;The more I learn and the more I read, the more I also realize there is always more to learn, to read, to create…&lt;/p&gt;

&lt;p&gt;Ultimately I try to convince myself those things don’t matter too much.  That’s just life.
During my time working as a software engineer I noticed, that it helps a lot for me to learn and understand a topic if I do this with the purpose of preparing to share my knowledge, through a talk, a meeting and similar.&lt;/p&gt;

&lt;p&gt;So this first blog post is really just for me to internalize what I try to teach myself for years and push my doubts away.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;It is okay if it sucks, I just do it for myself.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let’s live by the words of the famous Shia Laboeuf and &lt;em&gt;just do it&lt;/em&gt;.&lt;/p&gt;</content><author><name></name></author><category term="introduction" /><category term="aboutme" /><summary type="html">Hi! And welcome to my very first blog post. I have been struggling to start writing a blog for a long time for various reasons. I could list all reasons, however, thinking about it they all boil down to one main problem:</summary></entry></feed>